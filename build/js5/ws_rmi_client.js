"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.3.2
(function () {
  //!/bin/env/ coffee

  // ws_rmi_client.coffee

  var WS_RMI_Client,
      WS_RMI_Stub,
      WebSocket,
      log,
      splice = [].splice;

  WebSocket = (typeof window !== "undefined" && window !== null ? window.WebSocket : void 0) || require('ws');

  log = function log(msg) {
    return console.log(msg);
  };

  WS_RMI_Client = function () {
    function WS_RMI_Client(url1) {
      _classCallCheck(this, WS_RMI_Client);

      this.connect = this.connect.bind(this);
      this.onOpen = this.onOpen.bind(this);
      this.onMessage = this.onMessage.bind(this);
      this.onClose = this.onClose.bind(this);
      this.onError = this.onError.bind(this);
      this.disconnect = this.disconnect.bind(this);
      this.register = this.register.bind(this);
      this.send_request = this.send_request.bind(this);
      this.handle_response = this.handle_response.bind(this);
      this.url = url1;
      this.registry = {};
      this.cnt = 0;
      this.cb_hash = {};
      this.stubs = [];
    }

    _createClass(WS_RMI_Client, [{
      key: "connect",
      value: function connect(url) {
        if (url) {
          this.url = url;
        }
        this.server = new WebSocket(this.url);
        this.server.onopen = this.onOpen;
        this.server.onmessage = this.onMessage;
        this.server.onclose = this.onClose;
        this.server.onerror = this.onError;
        return true;
      }
    }, {
      key: "onOpen",
      value: function onOpen(evt) {
        return log("connected to rmi server at " + this.url);
      }
    }, {
      key: "onMessage",
      value: function onMessage(evt) {
        return this.handle_response(evt.data);
      }
    }, {
      key: "onClose",
      value: function onClose(evt) {
        return log("socket closed by server at " + this.url);
      }
    }, {
      key: "onError",
      value: function onError(evt) {}
    }, {
      key: "disconnect",
      value: function disconnect() {
        log("disconnecting from server at " + this.url);
        return this.server.close();
      }
    }, {
      key: "register",
      value: function register(stub) {
        this.stubs.push(stub);
        return stub.register(this);
      }
    }, {
      key: "send_request",
      value: function send_request(obj_id, name, args, cb) {
        var cb_id, rmi_args;
        cb_id = this.cnt++;
        this.cb_hash[cb_id] = cb != null && cb || console.log;
        rmi_args = {
          obj_id: obj_id,
          name: name,
          args: args,
          cb_id: cb_id
        };
        return this.server.send(JSON.stringify(rmi_args));
      }
    }, {
      key: "handle_response",
      value: function handle_response(msg) {
        var cb_id, res;

        var _JSON$parse = JSON.parse(msg);

        var _JSON$parse2 = _slicedToArray(_JSON$parse, 2);

        cb_id = _JSON$parse2[0];
        res = _JSON$parse2[1];

        this.cb_hash[cb_id](res);
        return delete this.cb_hash[cb_id];
      }
    }]);

    return WS_RMI_Client;
  }();

  // RMI_Stub is a generic rmi client super class Using it involves
  // extending it and calling the static (class) method 'remote_methods'
  // with a list of the methods available on the remote object.  The
  // resulting methods are just stubs which call the 'invoke' method
  // (below) to contact the remote object server.

  WS_RMI_Stub = function () {
    _createClass(WS_RMI_Stub, null, [{
      key: "add_stub",
      value: function add_stub(name) {
        return this.prototype[name] = function () {
          var _ref, _ref2, _splice$call, _splice$call2;

          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var cb, ref;
          ref = args, (_ref = ref, _ref2 = _toArray(_ref), args = _ref2.slice(0), _ref), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0], _splice$call);
          return this.invoke(name, args, cb);
        };
      }
    }]);

    function WS_RMI_Stub(id) {
      _classCallCheck(this, WS_RMI_Stub);

      this.register = this.register.bind(this);
      this.invoke = this.invoke.bind(this);
      this.id = id;
    }

    _createClass(WS_RMI_Stub, [{
      key: "log_cb",
      value: function log_cb(err, res) {
        return console.log(res);
      }
    }, {
      key: "register",
      value: function register(ws_rmi_client) {
        return this.ws_rmi_client = ws_rmi_client;
      }
    }, {
      key: "invoke",
      value: function invoke(name, args, cb) {
        cb = cb || function () {};
        return this.ws_rmi_client.send_request(this.id, name, args, cb);
      }
    }]);

    return WS_RMI_Stub;
  }();

  if (typeof window !== "undefined" && window !== null) {
    window.ws_rmi = {
      WS_RMI_Client: WS_RMI_Client,
      WS_RMI_Stub: WS_RMI_Stub
    };
  } else {
    exports.WS_RMI_Client = WS_RMI_Client;
    exports.WS_RMI_Stub = WS_RMI_Stub;
  }
}).call(undefined);

//# sourceURL=/home/carruth/git/ws_rmi/build/coffee/ws_rmi_client.coffee