'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.3.2
(function () {
  //!/bin/env/ coffee

  // ws_rmi_server_common.coffee

  var WS_RMI_Server_Common, WebSocket, log;

  WebSocket = require('ws');

  log = function log(msg) {
    return console.log(msg);
  };

  // WS_RMI_Server_Common contains code common to both
  // WS_RMI_Server and WSS_RMI_Server defined below

  WS_RMI_Server_Common = function () {
    function WS_RMI_Server_Common(server, host, port, path) {
      var _this = this;

      _classCallCheck(this, WS_RMI_Server_Common);

      // start the server

      this.start = this.start.bind(this);
      // register an object for remote method invocation by the
      // handle_request method (below)

      this.register = this.register.bind(this);
      // parse the request, use the obj_id to look up the
      // corresponding object and invoke the method on the
      // supplied arguments

      this.handle_request = this.handle_request.bind(this);
      this.server = server;
      this.host = host;
      this.port = port;
      this.path = path;
      this.registry = {};
      this.clients = [];
      this.wss = new WebSocket.Server({
        server: this.server
      });
      this.wss.on('connection', function (client) {
        client.on('message', function (msg) {
          return _this.handle_request(msg, client);
        });
        client.on('close', function () {
          return log('client disconnected: ' + client._socket.server._connectionKey);
        });
        _this.clients.push(client);
        return log('client added: ' + client._socket.server._connectionKey);
      });
    }

    _createClass(WS_RMI_Server_Common, [{
      key: 'start',
      value: function start() {
        var error;
        try {
          this.server.listen(this.port, this.host);
          return log('server listening at url: ' + this.protocol + '://' + this.host + ':' + this.port);
        } catch (error1) {
          error = error1;
          return console.log(error);
        }
      }
    }, {
      key: 'register',
      value: function register(obj) {
        this.registry[obj.id] = obj;
        log('registering ' + obj.id);
        return log(this.registry);
      }
    }, {
      key: 'handle_request',
      value: function handle_request(msg, client) {
        var args, cb_id, msg_obj, name, obj_id;
        msg_obj = JSON.parse(msg);
        //console.log msg_obj

        // args is a list - a splat from the original
        // client side invocation, so we need to "de-splat"
        // here.
        var _msg_obj = msg_obj;
        obj_id = _msg_obj.obj_id;
        name = _msg_obj.name;
        args = _msg_obj.args;
        cb_id = _msg_obj.cb_id;
        args.push(function (res) {
          return client.send(JSON.stringify([cb_id, res]));
        });
        return this.registry[obj_id][name].apply(null, args);
      }
    }]);

    return WS_RMI_Server_Common;
  }();

  exports.WS_RMI_Server_Common = WS_RMI_Server_Common;
}).call(undefined);

//# sourceURL=/home/carruth/git/ws_rmi/build/coffee/ws_rmi_server_common.coffee