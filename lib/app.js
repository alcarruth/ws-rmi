// Generated by CoffeeScript 2.4.1
(function() {
  //!/bin/env/ coffee

  //  ws_rmi_connection

  /*
  if not window?
    inspect = require('util').inspect

    inspect = (obj) ->
      options =
        showHidden: false
        depth: null
        colors: true
      util.inspect(obj, options)

    log = (heading, args...) ->
      args = args.map(inspect).join('\n')
      console.log("\n\n#{heading}\n#{args}\n\n")

  else
  */
  var WS_RMI_Connection, WS_RMI_Object, WS_RMI_Stub, log, random_id,
    indexOf = [].indexOf;

  log = console.log;

  //----------------------------------------------------------------------
  WS_RMI_Connection = class WS_RMI_Connection {
    // WS_RMI_Connection is basically just a wrapper around a websocket
    // and is intendend to be applied on both ends of the socket.  @owner
    // is the ws_rmi_client or the ws_rmi_server which established this
    // end of the websocket.

    // The idea here is that the connection, once established, is
    // symmetrical with both ends having the ability to request a remote
    // method invocation and to respond to such requests.

    // TODO: I have not settled the design as yet.  Previously the RMI's
    // were requested by a WS_RMI_Client and responded to by a
    // WS_RMI_Server.  My current thinking is that that functionality
    // might be better off here.

    constructor(owner, ws, log_level) {
      var i, len, obj, ref;
      //--------------------------------------------------------------------
      // Event handlers

      // TODO: is this event handled here or in client and server?  Seems
      // like by the time the connection object is constructed it's already
      // open.  Could it be closed and opened again?  I wouldn't think so
      // unless I implement that in the server and client code.  It'd have
      // to keep stale connection objects around and re-activate them when
      // connected again.

      this.onOpen = this.onOpen.bind(this);
      // This is the "main event".  It's what we've all been waiting for!
      this.onMessage = this.onMessage.bind(this);
      // TODO: perhaps somebody should be notified here ?-)
      // Who wanted this connection in the first place?  Do we
      // have their contact info?

      this.onClose = this.onClose.bind(this);
      // TODO: think of something to do here.
      this.onError = this.onError.bind(this);
      this.disconnect = this.disconnect.bind(this);
      //----------------------------------------------------------
      // Object registry methods

      // Register a WS_RMI_Object for RMI
      this.add_object = this.add_object.bind(this);
      this.register = this.register.bind(this);
      // I refuse to comment on what this one does.
      this.del_object = this.del_object.bind(this);
      // Method init() is a built-in remote method.
      this.get_stub_specs = this.get_stub_specs.bind(this);
      // Invoke remote init()
      this.init_stubs = this.init_stubs.bind(this);
      //--------------------------------------------------------------------
      // Generic messaging methods

      // JSON.stringify and send.  Returns a promise.
      this.send_message = this.send_message.bind(this);
      // JSON.parse and handle as appropriate.
      this.recv_message = this.recv_message.bind(this);
      //--------------------------------------------------------------------
      // Methods to Send and Receive RMI Requests

      // Method send_request()
      this.send_request = this.send_request.bind(this);
      // Method recv_request()
      this.recv_request = this.recv_request.bind(this);
      //--------------------------------------------------------------------
      //  Methods to Send and Receive RMI Responses

      // Method send_response()
      this.send_response = this.send_response.bind(this);
      // Method recv_resonse()
      this.recv_response = this.recv_response.bind(this);
      this.owner = owner;
      this.ws = ws;
      this.log_level = log_level || 0;
      // TODO: Need a unique id here. Does this work ok?
      //@id = "#{ws._socket.server._connectionKey}"
      this.id = "connection";
      // WS_RMI_Objects are registered here with their id as key.  The
      // registry is used by method recv_request() which receives just an
      // id in the message and must look up the object to invoke it's
      // method.

      this.registry = {};
      this.exclude = [];
      // Pseudo-object 'admin' with method 'init'

      // TODO: Is it better to use this pseudo-object approach or just
      // instantiate WS_RMI_Object to the same effect?  The point is that
      // 'admin' is special in that it is present at Connection creation
      // time.  It should be excluded from init() responses since the
      // caller already has it.  Should it then be excluded from the
      // registry or just skipped over when responding to init?  The
      // benefit of including it in the registry is that it requires no
      // special treatment in method recv_request().  My current choice
      // is to include it in the registry here and skip over it in
      // init().

      // In the future there may be other objects of this administrative
      // sort.  Maybe a more structured general solution should be
      // considered.

      this.admin = {
        id: 'admin',
        name: 'admin',
        get_stub_specs: this.get_stub_specs,
        method_names: ['get_stub_specs']
      };
      this.registry['admin'] = this.admin;
      this.exclude.push('admin');
      this.stubs = {};
      // RMI's are given a unique number and the Promise's resolve() and
      // reject() functions are kept as callbacks to be executed when an
      // RMI response is received. Properties @rmi_cnt and @rmi_hash are
      // each written and read by methods send_request() and
      // recv_response().

      this.rmi_cnt = 0;
      this.rmi_hash = {};
      ref = this.owner.objects;
      // add remote objects
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        this.add_object(obj);
      }
      // Events are mapped to handler methods defined below.
      this.ws.onopen = this.onOpen;
      this.ws.onmessage = this.onMessage;
      this.ws.onclose = this.onClose;
      this.ws.onerror = this.onError;
      true;
    }

    onOpen(evt) {
      if (this.log_level > 0) {
        return log("connection opened: id:", this.id);
      }
    }

    onMessage(evt) {
      if (this.log_level > 2) {
        log("onMessage:", evt.data);
      }
      return this.recv_message(evt.data);
    }

    onClose(evt) {
      if (this.log_level > 0) {
        return log("peer disconnected: id:", this.id);
      }
    }

    onError(evt) {}

    disconnect() {
      if (this.log_level > 0) {
        log("disconnecting: id: ", this.id);
      }
      return this.ws.close();
    }

    add_object(obj) {
      this.registry[obj.id] = obj;
      return obj.register(this);
    }

    register(obj) {
      return this.registry[obj.id] = obj;
    }

    del_object(id) {
      return delete this.registry[id];
    }

    get_stub_specs() {
      return new Promise((resolve, reject) => {
        var error, id, obj, ref, specs;
        try {
          specs = {};
          ref = this.registry;
          for (id in ref) {
            obj = ref[id];
            if (indexOf.call(this.exclude, id) < 0) {
              specs[id] = {
                name: obj.name,
                method_names: obj.method_names
              };
            }
          }
          if (this.log_level > 2) {
            log("init():", specs);
          }
          return resolve(specs);
        } catch (error1) {
          error = error1;
          log("Error: init():", specs, error);
          return reject("Error: init():", specs);
        }
      });
    }

    init_stubs() {
      var cb, eh;
      cb = (result) => {
        var id, method_names, name, results, spec, stub;
        if (this.log_level > 2) {
          log("init_stubs(): cb(): result:", result);
        }
        results = [];
        for (id in result) {
          spec = result[id];
          ({name, method_names} = spec);
          stub = new WS_RMI_Stub(id, name, method_names, this);
          results.push(this.stubs[stub.name] = stub);
        }
        return results;
      };
      eh = (error) => {
        if (this.log_level > 2) {
          log("init_stub(): eh(): received error:", error);
        }
        return new Error("init_stub(): eh(): received error:");
      };
      return this.send_request('admin', 'get_stub_specs', []).then(cb).catch(eh);
    }

    send_message(data_obj) {
      var error;
      if (this.log_level > 2) {
        log("send_message(): data_obj:", data_obj);
      }
      try {
        return this.ws.send(JSON.stringify(data_obj));
      } catch (error1) {
        error = error1;
        log("Error: send_message(): data_obj:", data_obj);
        return new Error(`send_message(): Error sending:\n ${inspect(data_obj)}`);
      }
    }

    recv_message(data) {
      var data_obj, msg, type;
      data_obj = JSON.parse(data);
      if (this.log_level > 2) {
        log("recv_message(): data_obj:", data_obj);
      }
      ({type, msg} = data_obj);
      if (type === 'request') {
        return this.recv_request(msg);
      }
      if (type === 'response') {
        return this.recv_response(msg);
      } else {
        return new Error(`recv_message(): invalid type ${type}`);
      }
    }

    send_request(obj_id, method, args) {
      var msg;
      msg = {
        obj_id: obj_id,
        method: method,
        args: args
      };
      if (this.log_level > 0) {
        log("send_request(): msg:", msg);
      }
      return new Promise((resolve, reject) => {
        var error;
        try {
          msg.rmi_id = this.rmi_cnt++;
          this.rmi_hash[msg.rmi_id] = {
            msg: msg,
            resolve: resolve,
            reject: reject
          };
          return this.send_message({
            type: 'request',
            msg: msg
          });
        } catch (error1) {
          error = error1;
          return reject("send_message(): Error: data_obj:", data_obj);
        }
      });
    }

    recv_request(msg) {
      var args, cb, eh, method, obj, obj_id, rmi_id;
      if (this.log_level > 0) {
        log("recv_request(): msg:", msg);
      }
      ({obj_id, method, args, rmi_id} = msg);
      // callback used below
      cb = (res) => {
        return this.send_response(rmi_id, res, null);
      };
      // error handler used below
      eh = (err) => {
        return this.send_response(rmi_id, null, err);
      };
      // Look up the object and apply the method to the args.
      // Method is assumed to return a promise.

      obj = this.registry[obj_id];
      return obj[method].apply(obj, args).then(cb).catch(eh);
    }

    send_response(rmi_id, result, error) {
      var msg;
      msg = {
        rmi_id: rmi_id,
        result: result,
        error: error
      };
      if (this.log_level > 0) {
        log("send_response(): msg:", msg);
      }
      return new Promise((resolve, reject) => {
        try {
          return this.send_message({
            type: 'response',
            msg: msg
          });
        } catch (error1) {
          error = error1;
          log("Error in send_response():", msg);
          return reject({rmi_id, result, error});
        }
      });
    }

    recv_response(response) {
      var error, reject, request, resolve, result, rmi_id;
      if (this.log_level > 0) {
        log("recv_response(): response:", response);
      }
      try {
        ({rmi_id, result, error} = response);
        ({request, resolve, reject} = this.rmi_hash[rmi_id]);
        if (error) {
          return reject({request, error});
        } else {
          return resolve(result);
        }
      } catch (error1) {
        error = error1;
        return reject({request, error});
      }
    }

  };

  //----------------------------------------------------------------------
  // WS_RMI_Object

  // used in WS_RMI_Object constructor
  random_id = function(name) {
    return `${name}_${(Math.random().toString().slice(2))}`;
  };

  // WS_RMI_Object wraps a regular coffeescript class instance object,
  // exposing only those methods explicitly intended for RMI.

  WS_RMI_Object = class WS_RMI_Object {
    constructor(name1, obj1, method_names1, log_level) {
      var i, len, name, ref;
      this.register = this.register.bind(this);
      this.name = name1;
      this.obj = obj1;
      this.method_names = method_names1;
      this.log_level = log_level || 0;
      this.id = random_id(this.name);
      ref = this.method_names;
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        this[name] = ((name) => {
          return function(...args) {
            return this.invoke(name, args);
          };
        })(name);
      }
    }

    register(connection) {
      return this.connection = connection;
    }

    // Method invoke() is called by connection.recv_request()
    // it executes the appropriate method and returns a promise.

    invoke(method_name, args) {
      var eh;
      // error handler used in .catch() just below.
      eh = (err) => {
        var msg;
        msg = "\nWS_RMI_Object:";
        msg += {
          id: this.id,
          method: name,
          args: args
        }.toString();
        return new Error(msg);
      };
      if (this.log_level > 1) {
        log("invoke(): ", {method_name, args});
      }
      // call the method of the underlying object
      return this.obj[method_name].apply(this.obj, args); // .catch(eh)
    }

  };

  
  //-----------------------------------------------------------------------
  // WS_RMI_Stub
  WS_RMI_Stub = class WS_RMI_Stub {
    constructor(id1, name1, method_names1, connection1, log_level) {
      var i, len, name, ref;
      this.id = id1;
      this.name = name1;
      this.method_names = method_names1;
      this.connection = connection1;
      this.log_level = log_level || 0;
      ref = this.method_names;
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        this[name] = ((name) => {
          return function(...args) {
            return this.invoke(name, args);
          };
        })(name);
      }
    }

    // Method invoke() implements local stub methods by calling
    // WS_RMI_Connection.send_request() which returns a Promise.

    invoke(name, args) {
      var eh;
      if (this.log_level > 1) {
        log("invoke(): ", {name, args});
      }
      eh = (err) => {
        var msg;
        msg = "\nWS_RMI_Stub:";
        msg += {
          id: this.id,
          method: name,
          args: args
        }.toString();
        return new Error(msg);
      };
      return this.connection.send_request(this.id, name, args).catch(eh);
    }

  };

  //----------------------------------------------------------------------
  exports.WS_RMI_Connection = WS_RMI_Connection;

  exports.WS_RMI_Object = WS_RMI_Object;

  exports.WS_RMI_Stub = WS_RMI_Stub;

}).call(this);
