// Generated by CoffeeScript 2.4.1
(function() {
  //!/bin/env/ coffee

  //  rmi.coffee

  //----------------------------------------------------------------------
  var WS_RMI_Connection, WS_RMI_Object, WS_RMI_Stub, random_id,
    indexOf = [].indexOf;

  WS_RMI_Connection = class WS_RMI_Connection {
    // RMI_Connection is basically just a wrapper around a socket and is
    // intendend to be applied on both ends of the websocket.  @owner is
    // the rmi_client or the rmi_server which established this end of the
    // websocket.

    // The idea here is that the connection, once established, is
    // symmetrical with both ends having the ability to request a remote
    // method invocation and to respond to such requests.

    // TODO: I have not settled the design as yet.  Previously the RMI's
    // were requested by a RMI_Client and responded to by a RMI_Server.
    // My current thinking is that that functionality might be better off
    // here.

    constructor(owner, ws, options) {
      var i, len, obj, ref, ref1, ref2;
      //--------------------------------------------------------------------
      // Event handlers

      // TODO: is this event handled here or in client and server?  Seems
      // like by the time the connection object is constructed it's already
      // open.  Could it be closed and opened again?  I wouldn't think so
      // unless I implement that in the server and client code.  It'd have
      // to keep stale connection objects around and re-activate them when
      // connected again.

      this.on_Open = this.on_Open.bind(this);
      // This is the "main event".  It's what we've all been waiting for!
      this.on_Message = this.on_Message.bind(this);
      // TODO: perhaps somebody should be notified here ?-) Who wanted this
      // connection in the first place?  Do we have their contact info?

      this.on_Close = this.on_Close.bind(this);
      // TODO: think of something to do here.
      this.on_Error = this.on_Error.bind(this);
      //----------------------------------------------------------

      this.disconnect = this.disconnect.bind(this);
      //----------------------------------------------------------
      // Object registry methods

      // Register a WS_RMI_Object for RMI
      this.add_object = this.add_object.bind(this);
      //register: (obj) =>
      //  @registry[obj.id] = obj

      // I refuse to comment on what this one does.
      this.del_object = this.del_object.bind(this);
      // Method get_stub_specs() is a server side built-in remote method.
      // It is invoked by method invoke_stubs() on the client side. (see
      // below)

      this.get_stub_specs = this.get_stub_specs.bind(this);
      // Call get_stub_specs() on the server side, then build the local
      // stubs for the remote objects' methods.

      this.init_stubs = this.init_stubs.bind(this);
      //--------------------------------------------------------------------
      // Generic messaging methods

      // JSON.stringify and send.  Returns a promise.
      this.send_message = this.send_message.bind(this);
      // JSON.parse and handle as appropriate.
      this.recv_message = this.recv_message.bind(this);
      //--------------------------------------------------------------------
      // Methods to Send and Receive RMI Requests

      // Method send_request()
      this.send_request = this.send_request.bind(this);
      // Method recv_request()
      this.recv_request = this.recv_request.bind(this);
      //--------------------------------------------------------------------
      //  Methods to Send and Receive RMI Responses

      // Method send_response()
      this.send_response = this.send_response.bind(this);
      // Method recv_resonse()
      this.recv_response = this.recv_response.bind(this);
      this.owner = owner;
      this.ws = ws;
      this.options = options;
      this.id = random_id('WS_RMI_Connection');
      this.log = ((ref = this.options) != null ? ref.log : void 0) || console.log;
      this.log_level = ((ref1 = this.options) != null ? ref1.log_level : void 0) || 1;
      this.waiter = null;
      // WS_RMI_Objects are registered here with their id as key.  The
      // registry is used by method recv_request() which receives just an
      // id in the message and must look up the object to invoke it's
      // method.

      this.registry = {};
      this.exclude = [];
      // Pseudo-object 'admin' with method 'init'

      // TODO: Is it better to use this pseudo-object approach or just
      // instantiate WS_RMI_Object to the same effect?  The point is that
      // 'admin' is special in that it is present at Connection creation
      // time.  It should be excluded from init() responses since the
      // caller already has it.  Should it then be excluded from the
      // registry or just skipped over when responding to init?  The
      // benefit of including it in the registry is that it requires no
      // special treatment in method recv_request().  My current choice
      // is to include it in the registry here and skip over it in
      // init().

      // In the future there may be other objects of this administrative
      // sort.  Maybe a more structured general solution should be
      // considered.

      this.admin = {
        id: 'admin',
        name: 'admin',
        get_stub_specs: this.get_stub_specs,
        method_names: ['get_stub_specs']
      };
      this.registry['admin'] = this.admin;
      this.exclude.push('admin');
      this.stubs = {};
      // RMI's are given a unique number and the Promise's resolve() and
      // reject() functions are kept as callbacks to be executed when an
      // RMI response is received. Properties @rmi_cnt and @rmi_hash are
      // each written and read by methods send_request() and
      // recv_response().

      this.rmi_cnt = 0;
      this.rmi_hash = {};
      ref2 = this.owner.objects;
      // add remote objects
      //@log("@owner.objects: #{@owner.objects}")
      for (i = 0, len = ref2.length; i < len; i++) {
        obj = ref2[i];
        this.add_object(obj);
      }
      // Events are mapped to handler methods defined below.

      this.ws.onopen = this.on_Open;
      this.ws.onmessage = this.on_Message;
      this.ws.onclose = this.on_Close;
      this.ws.onerror = this.on_Error;
      true;
    }

    async on_Open(evt) {
      // @log("connection opened: ", id: @id)
      await this.init_stubs();
      if (this.init != null) {
        return this.init();
      }
    }

    on_Message(evt) {
      if (this.log_level > 1) {
        this.log("WS_RMI_Connection.on_Message(): ", evt.data);
      }
      return this.recv_message(evt.data);
    }

    on_Close(evt) {
      if (this.log_level > 0) {
        return this.log("peer disconnected: ", {
          id: this.id
        });
      }
    }

    on_Error(evt) {
      this.log(evt.data);
      if (this.waiter) {
        return clearInterval(this.waiter);
      }
    }

    disconnect() {
      return this.ws.close();
    }

    add_object(obj) {
      this.registry[obj.id] = obj;
      return obj.set_connection(this);
    }

    del_object(id) {
      return delete this.registry[id];
    }

    get_stub_specs() {
      return new Promise((resolve, reject) => {
        var error, id, obj, ref, specs;
        try {
          specs = {};
          ref = this.registry;
          for (id in ref) {
            obj = ref[id];
            if (indexOf.call(this.exclude, id) < 0) {
              specs[id] = {
                name: obj.name,
                method_names: obj.method_names
              };
            }
          }
          if (this.log_level > 1) {
            this.log("get_stub_specs():", specs);
          }
          return resolve(specs);
        } catch (error1) {
          error = error1;
          this.log("Error: init():", specs, error);
          return reject("Error: init():", specs);
        }
      });
    }

    init_stubs() {
      var cb, eh;
      // callback
      cb = (result) => {
        var id, method_names, name, results, spec, stub;
        if (this.log_level > 1) {
          this.log("init_stubs(): cb(): ", {
            result: result
          });
        }
        results = [];
        for (id in result) {
          spec = result[id];
          ({name, method_names} = spec);
          stub = new WS_RMI_Stub(id, name, method_names, this);
          results.push(this.stubs[stub.name] = stub);
        }
        return results;
      };
      // error handler
      eh = (error) => {
        return this.log("init_stubs(): eh(): received error:", error);
      };
      if (this.log_level > 1) {
        this.log("init_stubs(): begin");
      }
      // @send_request() returns a promise
      return this.send_request('admin', 'get_stub_specs', []).then(cb).catch(eh);
    }

    send_message(data_obj) {
      var delay, error, max_tries, tries;
      if (this.log_level > 1) {
        this.log("send_message(): ", {
          data_obj: data_obj,
          '@ws.readyState': this.ws.readyState
        });
      }
      try {
        // The WebSocket API seems flawed.  When a new ws is created as
        // in 'new WebSocket(url)' it attempts to connect to the server
        // at url.  Until then ws.readyState == ws.CONNECTING and any
        // attempt to send a message will throw an error.  An 'open'
        // event is emmitted when ws.readyState == ws.OPEN and you can
        // set ws.onOpen to handle this event, but only AFTER the attempt
        // to connect has already begun.  So there is a race condition
        // between setting the handler and completing the connect
        // protocol.

        // The code below is intended to handle this.  It runs every time
        // send_message() is called but is really only necessary in the
        // beginning when the ws has just been created.

        // If the ws is connected then proceed as normal.

        if (this.ws.readyState === this.ws.OPEN) {
          return this.ws.send(JSON.stringify(data_obj));
        // If not ready but we're still connecting, then check again
        // every ${delay} ms.

        } else if (this.ws.readyState === this.ws.CONNECTING) {
          delay = 100;
          max_tries = 30;
          tries = 0;
          return this.waiter = setInterval((() => {
            this.log(`waiting ${delay} ms...`);
            tries += 1;
            if (this.ws.readyState === this.ws.OPEN || tries >= max_tries) {
              clearInterval(this.waiter);
              return this.ws.send(JSON.stringify(data_obj));
            }
          }), delay);
        } else {
          // The other possible states are CLOSED and CLOSING.  Either
          // of these is an error.

          throw new Error('ws.readyState not OPEN or CONNECTING');
        }
      } catch (error1) {
        error = error1;
        return this.log("Error: send_message(): ", {
          data_obj: data_obj,
          error: error
        });
      }
    }

    recv_message(data) {
      var msg, type;
      if (this.log_level > 1) {
        this.log("WS_RMI_Connection.recv_message() ", {
          data: data
        });
      }
      ({type, msg} = JSON.parse(data));
      if (this.log_level > 1) {
        this.log({
          type: type,
          msg: msg
        });
      }
      if (type === 'request') {
        return this.recv_request(msg);
      }
      if (type === 'response') {
        return this.recv_response(msg);
      } else {
        throw new Error(`recv_message(): invalid type ${type}`);
      }
    }

    send_request(obj_id, method, args) {
      var msg;
      msg = {
        obj_id: obj_id,
        method: method,
        args: args
      };
      if (this.log_level > 1) {
        this.log("send_request(): ", {
          msg: msg
        });
      }
      return new Promise((resolve, reject) => {
        var error;
        try {
          msg.rmi_id = this.rmi_cnt++;
          this.rmi_hash[msg.rmi_id] = {
            msg: msg,
            resolve: resolve,
            reject: reject
          };
          return this.send_message({
            type: 'request',
            msg: msg
          });
        } catch (error1) {
          error = error1;
          return reject("send_message(): Error: data_obj:", data_obj);
        }
      });
    }

    recv_request(msg) {
      var args, cb, eh, method, obj, obj_id, rmi_id;
      if (this.log_level > 1) {
        this.log("recv_request(): ", {
          msg: msg
        });
      }
      ({obj_id, method, args, rmi_id} = msg);
      // callback used below
      cb = (res) => {
        return this.send_response(rmi_id, res, null);
      };
      // error handler used below
      eh = (err) => {
        return this.send_response(rmi_id, null, err);
      };
      // Look up the object and apply the method to the args.  Method is
      // assumed to return a promise.

      obj = this.registry[obj_id];
      return obj[method].apply(obj, args).then(cb).catch(eh);
    }

    send_response(rmi_id, result, error) {
      var msg;
      msg = {
        rmi_id: rmi_id,
        result: result,
        error: error
      };
      if (this.log_level > 1) {
        this.log("send_response(): ", {
          msg: msg
        });
      }
      return new Promise((resolve, reject) => {
        try {
          return this.send_message({
            type: 'response',
            msg: msg
          });
        } catch (error1) {
          error = error1;
          this.log("Error in send_response():", {
            msg: msg
          });
          return reject({rmi_id, result, error});
        }
      });
    }

    recv_response(response) {
      var error, reject, request, resolve, result, rmi_id;
      if (this.log_level > 1) {
        this.log("recv_response(): ", {
          response: response
        });
      }
      try {
        ({rmi_id, result, error} = response);
        ({request, resolve, reject} = this.rmi_hash[rmi_id]);
        if (error) {
          return reject({request, error});
        } else {
          return resolve(result);
        }
      } catch (error1) {
        error = error1;
        return reject({request, error});
      }
    }

  };

  //----------------------------------------------------------------------
  // WS_RMI_Object

  // used in WS_RMI_Object constructor
  random_id = function(name) {
    return `${name}_${(Math.random().toString().slice(2))}`;
  };

  // RMI_Object wraps a regular coffeescript class instance object,
  // exposing only those methods explicitly intended for RMI.

  WS_RMI_Object = class WS_RMI_Object {
    constructor(name1, obj1, method_names1, options) {
      var i, len, name, ref, ref1, ref2;
      this.set_connection = this.set_connection.bind(this);
      this.name = name1;
      this.obj = obj1;
      this.method_names = method_names1;
      this.options = options;
      this.log_level = ((ref = this.options) != null ? ref.log_level : void 0) || 1;
      this.log = ((ref1 = this.options) != null ? ref1.log : void 0) || console.log;
      this.id = random_id(this.name);
      ref2 = this.method_names;
      for (i = 0, len = ref2.length; i < len; i++) {
        name = ref2[i];
        this[name] = ((name) => {
          return function(...args) {
            return this.invoke(name, args);
          };
        })(name);
      }
    }

    set_connection(conn) {
      return this.connection = conn;
    }

    // Method invoke() is called by connection.recv_request() it executes
    // the appropriate method and returns a promise.

    invoke(method_name, args) {
      var eh;
      // error handler used in .catch() just below.
      eh = (err) => {
        var msg;
        msg = "\nWS_RMI_Object:";
        msg += {
          id: this.id,
          method: name,
          args: args
        }.toString();
        return new Error(msg);
      };
      if (this.log_level > 1) {
        this.log("invoke(): ", {method_name, args});
      }
      // call the method of the underlying object
      return this.obj[method_name].apply(this.obj, args); // .catch(eh)
    }

  };

  
  //-----------------------------------------------------------------------
  // WS_RMI_Stub
  WS_RMI_Stub = class WS_RMI_Stub {
    constructor(id1, name1, method_names1, connection, options) {
      var i, len, name, ref, ref1, ref2;
      this.id = id1;
      this.name = name1;
      this.method_names = method_names1;
      this.connection = connection;
      this.options = options;
      this.log_level = ((ref = this.options) != null ? ref.log_level : void 0) || 0;
      this.log = ((ref1 = this.options) != null ? ref1.log : void 0) || console.log;
      ref2 = this.method_names;
      for (i = 0, len = ref2.length; i < len; i++) {
        name = ref2[i];
        this[name] = ((name) => {
          return function(...args) {
            return this.invoke(name, args);
          };
        })(name);
      }
    }

    // Method invoke() implements local stub methods by calling
    // WS_RMI_Connection.send_request() which returns a Promise.

    invoke(name, args) {
      var eh;
      if (this.log_level > 1) {
        this.log("invoke(): ", {name, args});
      }
      eh = (err) => {
        var msg;
        msg = "\nWS_RMI_Stub:";
        msg += {
          id: this.id,
          method: name,
          args: args
        }.toString();
        return new Error(msg);
      };
      return this.connection.send_request(this.id, name, args).catch(eh);
    }

  };

  //----------------------------------------------------------------------
  exports.Connection = WS_RMI_Connection;

  exports.Object = WS_RMI_Object;

  exports.Stub = WS_RMI_Stub;

}).call(this);
