// Generated by CoffeeScript 2.4.1
(function() {
  //!/bin/env/ coffee

  //  ws_rmi_server

  var RMI_Connection, WS_RMI_Server, fs, http, https, ws;

  fs = require('fs');

  ws = require('ws');

  http = require('http');

  https = require('https');

  RMI_Connection = require('./rmi').Connection;

  // An instance of WS_RMI_Server provides remote method invocation (RMI)
  // services for its @objects to clients connected by a websocket.

  WS_RMI_Server = class WS_RMI_Server {
    // @objects: an array of remotable objects

    // @options: options for the http(s) server and for logging etc.

    // Connection: a connection class extending WS_RMI_Connection.
    // It defaults to WS_RMI_Connection.  A subclass can be used to provide
    // extra functionality particular to the type of rmi objects being served.
    // At this point the only known reason for providing this option is for
    // the db_rmi stuff which required additional setup after @init_stubs().
    // It seems like this might frequently be the case though...

    constructor(objects, options = {}, Connection) {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6;
      // Method start()
      // Start the server.

      this.start = this.start.bind(this);
      this.cleanup = this.cleanup.bind(this);
      // Method stop()
      // Stop the server.

      // TODO: stop() should be called before exiting. Isn't there a way to do
      // automatic cleanup?  Or am I thinking of Python or something else?

      this.stop = this.stop.bind(this);
      this.objects = objects;
      this.options = options;
      this.id = `WS_RMI_Server-${(Math.random().toString().slice(2))}`;
      this.log_level = ((ref = this.options) != null ? ref.log_level : void 0) || 2;
      this.log = ((ref1 = this.options) != null ? ref1.log : void 0) || console.log;
      // default to 'ws+unix'
      this.protocol = ((ref2 = this.options) != null ? ref2.protocol : void 0) || 'ws+unix';
      // Protocol 'ws+unix' means IPC (inter process communication),
      // basically unix domain sockets (or something similar in
      // Windows). See docs for npm package ws.

      if (this.protocol === 'ws+unix') {
        this.path = ((ref3 = this.options) != null ? ref3.path : void 0) || '/tmp/ipc_rmi';
        this.url = `ws+unix://${this.path}`;
        // TODO: this is suppose to do cleanup.
        // It doesn't work.

        process.on('exit', this.cleanup);
        process.on('SIGQUIT', this.cleanup);
        process.on('SIGINT', this.cleanup);
        process.on('SIGKILL', this.cleanup);
        this.server.on('close', this.cleanup);
      } else {
        // Otherwise we need the usual TCP options.
        this.host = ((ref4 = this.options) != null ? ref4.host : void 0) || localhost;
        this.port = ((ref5 = this.options) != null ? ref5.port : void 0) || 8007;
        this.path = ((ref6 = this.options) != null ? ref6.path : void 0) || '';
        this.url = `${this.protocol}://${this.host}:${this.port}/${this.path}`;
      }
      // connections added here as they are created
      this.connections = [];
      // The connection class - defaults to RMI_Connection
      this.Connection = Connection || RMI_Connection;
      // wss means secure websocket so we'll use https
      if (this.protocol === 'wss') {
        this.server = new https.Server(null, this.options.credentials);
      } else {
        // otherwise just use http
        this.server = new http.Server(null);
      }
      // Create the WebSocket server providing the http(s) server
      // created just above.

      this.wss = new ws.Server({
        server: this.server
      });
      this.wss.on('connection', (ws) => {
        var conn, error, msg;
        try {
          this.log(`trying new connection: ${ws}`);
          conn = new this.Connection(this, ws, this.options);
          this.connections.push(conn);
          return this.log(`connection added: ${conn.id}`);
        } catch (error1) {
          error = error1;
          msg = "\nWS_RMI_Server_Common: ";
          msg += "\nError in connection event handler";
          return new Error(msg);
        }
      });
    }

    start() {
      var error;
      try {
        // Unix domain socket so just use @path
        if (this.protocol === 'ws+unix') {
          this.server.listen({
            path: this.path
          });
        } else {
          // otherwise start with TCP options
          this.server.listen({
            host: this.host,
            port: this.port
          });
        }
        return this.log("server listening at ", this.url);
      } catch (error1) {
        error = error1;
        return this.log(error);
      }
    }

    cleanup() {
      if (fs.existsSync(this.path)) {
        console.log(`deleting ${this.path}`);
        return fs.unlink_sync(this.path);
      }
    }

    stop() {
      this.server.close();
      return this.log("server stopped.");
    }

  };

  module.exports = WS_RMI_Server;

}).call(this);
