// Generated by CoffeeScript 2.4.1
(function() {
  //!/bin/env/ coffee

  //  rmi.coffee

  //----------------------------------------------------------------------
  var WS_RMI_Connection, WS_RMI_Object, WS_RMI_Stub, random_id,
    indexOf = [].indexOf;

  WS_RMI_Connection = class WS_RMI_Connection {
    // RMI_Connection is basically just a wrapper around a socket
    // and is intendend to be applied on both ends of the websocket.  @owner
    // is the rmi_client or the rmi_server which established this
    // end of the websocket.

    // The idea here is that the connection, once established, is
    // symmetrical with both ends having the ability to request a remote
    // method invocation and to respond to such requests.

    // TODO: I have not settled the design as yet.  Previously the RMI's
    // were requested by a RMI_Client and responded to by a
    // RMI_Server.  My current thinking is that that functionality
    // might be better off here.

    constructor(owner, ws, options) {
      var i, len, obj, ref;
      //--------------------------------------------------------------------
      // Event handlers

      // TODO: is this event handled here or in client and server?  Seems
      // like by the time the connection object is constructed it's already
      // open.  Could it be closed and opened again?  I wouldn't think so
      // unless I implement that in the server and client code.  It'd have
      // to keep stale connection objects around and re-activate them when
      // connected again.

      this.on_Open = this.on_Open.bind(this);
      // This is the "main event".  It's what we've all been waiting for!
      this.on_Message = this.on_Message.bind(this);
      // TODO: perhaps somebody should be notified here ?-)
      // Who wanted this connection in the first place?  Do we
      // have their contact info?

      this.on_Close = this.on_Close.bind(this);
      // TODO: think of something to do here.
      this.on_Error = this.on_Error.bind(this);
      //----------------------------------------------------------

      this.disconnect = this.disconnect.bind(this);
      //----------------------------------------------------------
      // Object registry methods

      // Register a WS_RMI_Object for RMI
      this.add_object = this.add_object.bind(this);
      this.register = this.register.bind(this);
      // I refuse to comment on what this one does.
      this.del_object = this.del_object.bind(this);
      // Method get_stub_specs() is a built-in remote method.
      this.get_stub_specs = this.get_stub_specs.bind(this);
      // Invoke remote get_stub_specs()
      this.init_stubs = this.init_stubs.bind(this);
      //--------------------------------------------------------------------
      // Generic messaging methods

      // JSON.stringify and send.  Returns a promise.
      this.send_message = this.send_message.bind(this);
      // JSON.parse and handle as appropriate.
      this.recv_message = this.recv_message.bind(this);
      //--------------------------------------------------------------------
      // Methods to Send and Receive RMI Requests

      // Method send_request()
      this.send_request = this.send_request.bind(this);
      // Method recv_request()
      this.recv_request = this.recv_request.bind(this);
      //--------------------------------------------------------------------
      //  Methods to Send and Receive RMI Responses

      // Method send_response()
      this.send_response = this.send_response.bind(this);
      // Method recv_resonse()
      this.recv_response = this.recv_response.bind(this);
      this.owner = owner;
      this.ws = ws;
      this.id = random_id('WS_RMI_Connection');
      this.log = (options != null ? options.log : void 0) || console.log;
      this.log_level = (options != null ? options.log_level : void 0) || 2;
      this.waiter = null;
      // WS_RMI_Objects are registered here with their id as key.  The
      // registry is used by method recv_request() which receives just an
      // id in the message and must look up the object to invoke it's
      // method.

      this.registry = {};
      this.exclude = [];
      // Pseudo-object 'admin' with method 'init'

      // TODO: Is it better to use this pseudo-object approach or just
      // instantiate WS_RMI_Object to the same effect?  The point is that
      // 'admin' is special in that it is present at Connection creation
      // time.  It should be excluded from init() responses since the
      // caller already has it.  Should it then be excluded from the
      // registry or just skipped over when responding to init?  The
      // benefit of including it in the registry is that it requires no
      // special treatment in method recv_request().  My current choice
      // is to include it in the registry here and skip over it in
      // init().

      // In the future there may be other objects of this administrative
      // sort.  Maybe a more structured general solution should be
      // considered.

      this.admin = {
        id: 'admin',
        name: 'admin',
        get_stub_specs: this.get_stub_specs,
        method_names: ['get_stub_specs']
      };
      this.registry['admin'] = this.admin;
      this.exclude.push('admin');
      this.stubs = {};
      // RMI's are given a unique number and the Promise's resolve() and
      // reject() functions are kept as callbacks to be executed when an
      // RMI response is received. Properties @rmi_cnt and @rmi_hash are
      // each written and read by methods send_request() and
      // recv_response().

      this.rmi_cnt = 0;
      this.rmi_hash = {};
      // add remote objects
      this.log(`@owner.objects: ${this.owner.objects}`);
      ref = this.owner.objects;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        this.add_object(obj);
      }
      // Events are mapped to handler methods defined below.

      // TODO: the chrome WebSocket class has no 'on' method, but the
      // 'ws' library does.  Need to simplify.

      if (this.ws.on) {
        this.ws.on('open', this.on_Open);
        this.ws.on('message', this.on_Message);
        this.ws.on('close', this.on_Close);
        this.ws.on('error', this.on_Error);
      } else {
        // TODO: these might work for the 'ws' websocket library
        // also.  If so, we can lose the above case and just use the
        // following else part.  Try it in ipc mode.

        this.ws.onopen = (e) => {
          return this.on_Open(e.data);
        };
        this.ws.onmessage = (e) => {
          return this.on_Message(e.data);
        };
        this.ws.onclose = (e) => {
          return this.on_Close(e.data);
        };
        this.ws.onerror = (e) => {
          return this.on_Error(e.data);
        };
      }
      true;
    }

    on_Open(evt) {
      this.log("connection opened: id:", this.id);
      return this.init_stubs();
    }

    on_Message(data) {
      if (this.log_level > 1) {
        this.log("WS_RMI_Connection.on_Message(): ", data);
      }
      return this.recv_message(data);
    }

    on_Close(evt) {
      if (this.log_level > 1) {
        return this.log("peer disconnected: id:", this.id);
      }
    }

    on_Error(evt) {
      this.log(evt.data);
      if (this.waiter) {
        return clearInterval(this.waiter);
      }
    }

    disconnect() {
      return this.ws.close();
    }

    add_object(obj) {
      this.registry[obj.id] = obj;
      return obj.register(this);
    }

    register(obj) {
      return this.registry[obj.id] = obj;
    }

    del_object(id) {
      return delete this.registry[id];
    }

    get_stub_specs() {
      return new Promise((resolve, reject) => {
        var error, id, obj, ref, specs;
        try {
          specs = {};
          ref = this.registry;
          for (id in ref) {
            obj = ref[id];
            if (indexOf.call(this.exclude, id) < 0) {
              specs[id] = {
                name: obj.name,
                method_names: obj.method_names
              };
            }
          }
          if (this.log_level > 1) {
            this.log("get_stub_specs():", specs);
          }
          return resolve(specs);
        } catch (error1) {
          error = error1;
          this.log("Error: init():", specs, error);
          return reject("Error: init():", specs);
        }
      });
    }

    init_stubs() {
      var cb, eh;
      cb = (result) => {
        var id, method_names, name, results, spec, stub;
        if (this.log_level > 1) {
          this.log("init_stubs(): cb(): result:", result);
        }
        results = [];
        for (id in result) {
          spec = result[id];
          ({name, method_names} = spec);
          stub = new WS_RMI_Stub(id, name, method_names, this);
          results.push(this.stubs[stub.name] = stub);
        }
        return results;
      };
      eh = (error) => {
        if (this.log_level > 1) {
          return this.log("init_stub(): eh(): received error:", error);
        }
      };
      this.log("init_stub(): eh(): received error:");
      if (this.log_level > 1) {
        this.log("init_stubs(): begin");
      }
      // @send_request() returns a promise
      return this.send_request('admin', 'get_stub_specs', []).then(cb).catch(eh);
    }

    send_message(data_obj) {
      var delay, error, max_tries, tries;
      if (this.log_level > 1) {
        this.log("send_message(): data_obj:", data_obj);
        this.log(`@ws.readyState = ${this.ws.readyState}`);
      }
      try {
        // The WebSocket API seems flawed.  When a new ws is created
        // as in 'new WebSocket(url)' it attempts to connect to the server
        // at url.  Until then ws.readyState == ws.CONNECTING and any
        // attempt to send a message will throw an error.  An 'open' event
        // is emmitted when ws.readyState == ws.OPEN and you can set
        // ws.onOpen to handle this event, but only AFTER the attempt to
        // connect has already begun.  So there is a race condition between
        // setting the handler and completing the connect protocol.

        // The code below is intended to handle this.  It runs every time
        // send_message() is called but is really only necessary in the
        // beginning when the ws has just been created.

        // If the ws is connected then proceed as normal.

        if (this.ws.readyState === this.ws.OPEN) {
          return this.ws.send(JSON.stringify(data_obj));
        // If not ready but we're still connecting, then check again
        // every ${delay} ms.

        } else if (this.ws.readyState === this.ws.CONNECTING) {
          delay = 100;
          max_tries = 30;
          tries = 0;
          return this.waiter = setInterval((() => {
            this.log(`waiting ${delay} ms...`);
            tries += 1;
            if (this.ws.readyState === this.ws.OPEN || tries >= max_tries) {
              clearInterval(this.waiter);
              return this.ws.send(JSON.stringify(data_obj));
            }
          }), delay);
        } else {
          // The other possible states are CLOSED and CLOSING.  Either
          // of these is an error.

          throw new Error('ws.readyState not OPEN or CONNECTING');
        }
      } catch (error1) {
        error = error1;
        this.log("Error: send_message(): data_obj:", data_obj);
        return this.log(error);
      }
    }

    recv_message(data) {
      var msg, type;
      if (this.log_level > 1) {
        this.log("WS_RMI_Connection.recv_message() ");
        this.log(`data: ${data}`);
      }
      ({type, msg} = JSON.parse(data));
      if (this.log_level > 1) {
        this.log(`type: ${type}`);
        this.log(`msg: ${msg}`);
      }
      if (type === 'request') {
        return this.recv_request(msg);
      }
      if (type === 'response') {
        return this.recv_response(msg);
      } else {
        throw new Error(`recv_message(): invalid type ${type}`);
      }
    }

    send_request(obj_id, method, args) {
      var msg;
      msg = {
        obj_id: obj_id,
        method: method,
        args: args
      };
      if (this.log_level > 1) {
        this.log("send_request(): msg:", msg);
      }
      return new Promise((resolve, reject) => {
        var error;
        try {
          msg.rmi_id = this.rmi_cnt++;
          this.rmi_hash[msg.rmi_id] = {
            msg: msg,
            resolve: resolve,
            reject: reject
          };
          return this.send_message({
            type: 'request',
            msg: msg
          });
        } catch (error1) {
          error = error1;
          return reject("send_message(): Error: data_obj:", data_obj);
        }
      });
    }

    recv_request(msg) {
      var args, cb, eh, method, obj, obj_id, rmi_id;
      if (this.log_level > 1) {
        this.log("recv_request(): msg:", msg);
      }
      ({obj_id, method, args, rmi_id} = msg);
      // callback used below
      cb = (res) => {
        return this.send_response(rmi_id, res, null);
      };
      // error handler used below
      eh = (err) => {
        return this.send_response(rmi_id, null, err);
      };
      // Look up the object and apply the method to the args.
      // Method is assumed to return a promise.

      obj = this.registry[obj_id];
      return obj[method].apply(obj, args).then(cb).catch(eh);
    }

    send_response(rmi_id, result, error) {
      var msg;
      msg = {
        rmi_id: rmi_id,
        result: result,
        error: error
      };
      if (this.log_level > 1) {
        this.log("send_response(): msg:", msg);
      }
      return new Promise((resolve, reject) => {
        try {
          return this.send_message({
            type: 'response',
            msg: msg
          });
        } catch (error1) {
          error = error1;
          this.log("Error in send_response():", msg);
          return reject({rmi_id, result, error});
        }
      });
    }

    recv_response(response) {
      var error, reject, request, resolve, result, rmi_id;
      if (this.log_level > 1) {
        this.log("recv_response(): response:", response);
      }
      try {
        ({rmi_id, result, error} = response);
        ({request, resolve, reject} = this.rmi_hash[rmi_id]);
        if (error) {
          return reject({request, error});
        } else {
          return resolve(result);
        }
      } catch (error1) {
        error = error1;
        return reject({request, error});
      }
    }

  };

  //----------------------------------------------------------------------
  // WS_RMI_Object

  // used in WS_RMI_Object constructor
  random_id = function(name) {
    return `${name}_${(Math.random().toString().slice(2))}`;
  };

  // RMI_Object wraps a regular coffeescript class instance object,
  // exposing only those methods explicitly intended for RMI.

  WS_RMI_Object = class WS_RMI_Object {
    constructor(name1, obj1, method_names1, options) {
      var i, len, name, ref;
      this.register = this.register.bind(this);
      this.name = name1;
      this.obj = obj1;
      this.method_names = method_names1;
      this.options = options;
      this.log_level = (options != null ? options.log_level : void 0) || 0;
      this.log = (options != null ? options.log : void 0) || console.log;
      this.id = random_id(this.name);
      ref = this.method_names;
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        this[name] = ((name) => {
          return function(...args) {
            return this.invoke(name, args);
          };
        })(name);
      }
    }

    register(connection) {
      return this.connection = connection;
    }

    // Method invoke() is called by connection.recv_request()
    // it executes the appropriate method and returns a promise.

    invoke(method_name, args) {
      var eh;
      // error handler used in .catch() just below.
      eh = (err) => {
        var msg;
        msg = "\nWS_RMI_Object:";
        msg += {
          id: this.id,
          method: name,
          args: args
        }.toString();
        return new Error(msg);
      };
      if (this.log_level > 1) {
        this.log("invoke(): ", {method_name, args});
      }
      // call the method of the underlying object
      return this.obj[method_name].apply(this.obj, args); // .catch(eh)
    }

  };

  
  //-----------------------------------------------------------------------
  // WS_RMI_Stub
  WS_RMI_Stub = class WS_RMI_Stub {
    constructor(id1, name1, method_names1, connection1, options) {
      var i, len, name, ref;
      this.id = id1;
      this.name = name1;
      this.method_names = method_names1;
      this.connection = connection1;
      this.log_level = (options != null ? options.log_level : void 0) || 0;
      this.log = (options != null ? options.log : void 0) || console.log;
      ref = this.method_names;
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        this[name] = ((name) => {
          return function(...args) {
            return this.invoke(name, args);
          };
        })(name);
      }
    }

    // Method invoke() implements local stub methods by calling
    // WS_RMI_Connection.send_request() which returns a Promise.

    invoke(name, args) {
      var eh;
      if (this.log_level > 1) {
        this.log("invoke(): ", {name, args});
      }
      eh = (err) => {
        var msg;
        msg = "\nWS_RMI_Stub:";
        msg += {
          id: this.id,
          method: name,
          args: args
        }.toString();
        return new Error(msg);
      };
      return this.connection.send_request(this.id, name, args).catch(eh);
    }

  };

  //----------------------------------------------------------------------
  exports.Connection = WS_RMI_Connection;

  exports.Object = WS_RMI_Object;

  exports.Stub = WS_RMI_Stub;

}).call(this);
